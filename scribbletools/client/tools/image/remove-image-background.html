<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Remove Image Background - FREE AI Background Remover Tool</title>
  <meta name="description" content="Free AI background remover! Remove photo backgrounds instantly with open-source AI. No signup, fast processing, completely private. 100% free!">
  <meta name="keywords" content="remove background, background remover, ai background remover, free background remover, photo background remover, image background remover, remove photo background, background eraser, transparent background, cut out background, background removal tool, ai photo editor, automatic background removal, photo editing tool, image editing tool, background cleaner, photo cutout tool, transparent png maker, product photo editor, portrait background remover, object isolation tool, background deletion tool, photo backdrop remover, image background editor, free photo editor, ai photo processing, background extraction tool, photo transparency tool, image cutout tool">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://scribbletools.shramkavach.com/client/tools/image/remove-image-background.html">
  <meta property="og:title" content="Remove Image Background - FREE AI Background Remover Tool">
  <meta property="og:description" content="Free AI background remover! Remove photo backgrounds instantly with open-source AI. No signup, fast processing, completely private. 100% free!">
  <meta property="og:image" content="https://scribbletools.shramkavach.com/assets/og-image.svg">
  <meta property="og:site_name" content="Scribble Tools">
  <meta property="og:locale" content="en_US">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://scribbletools.shramkavach.com/client/tools/image/remove-image-background.html">
  <meta property="twitter:title" content="Remove Image Background - FREE AI Background Remover Tool">
  <meta property="twitter:description" content="Free AI background remover! Remove photo backgrounds instantly with open-source AI. No signup, fast processing, completely private. 100% free!">
  <meta property="twitter:image" content="https://scribbletools.shramkavach.com/assets/og-image.svg">
  
  <!-- Additional SEO Meta Tags -->
  <meta name="robots" content="index, follow">
  <meta name="author" content="Scribble Tools">
  <meta name="generator" content="Scribble Tools">
  <meta name="application-name" content="AI Background Remover">
  <meta name="apple-mobile-web-app-title" content="Background Remover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#D9534F">
  <meta name="msapplication-navbutton-color" content="#D9534F">
  <meta name="apple-mobile-web-app-status-bar-style" content="#D9534F">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://scribbletools.shramkavach.com/client/tools/image/remove-image-background.html">
  
  <!-- Preconnect for Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "AI Background Remover",
    "description": "Free AI-powered background remover tool for instantly removing backgrounds from photos using open-source AI technology.",
    "url": "https://scribbletools.shramkavach.com/client/tools/image/remove-image-background.html",
    "applicationCategory": "MultimediaApplication",
    "operatingSystem": "Any",
    "permissions": "browser",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "AI-powered background removal",
      "Automatic object detection",
      "Transparent PNG output",
      "No signup required",
      "Private processing",
      "Open-source AI",
      "Free to use",
      "Instant results"
    ],
    "provider": {
      "@type": "Organization",
      "name": "Scribble Tools",
      "url": "https://scribbletools.shramkavach.com"
    }
  }
  </script>
  
  <style>
    .remove-bg-tool body { font-family: 'Poppins', sans-serif; background: #F8F4E8; color: #333; }
    .remove-bg-tool main { display: block; }
    .remove-bg-tool .reduce-size-container { max-width: 800px; margin: 3em auto; background: #fff; border-radius: 1.2em; box-shadow: 0 4px 24px #eae3d5; padding: 2em 1.5em 2.5em 1.5em; }
    .remove-bg-tool .handwritten { font-family: 'Caveat', cursive; }
    .remove-bg-tool .upload-area { border: 3px dashed #D9534F; border-radius: 1em; padding: 3em 2em; text-align: center; margin: 2em 0; background: #FDFBF5; transition: all 0.3s; cursor: pointer; }
    .remove-bg-tool .upload-area:hover { background: #F0F8FF; border-color: #4682B4; }
    .remove-bg-tool .upload-icon { font-size: 3em; color: #D9534F; margin-bottom: 1em; text-align: center; }
    .remove-bg-tool .file-input { display: none; }
    .remove-bg-tool .upload-btn { background: #D9534F; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; display: block; margin: 0 auto 1.5em auto; }
    .remove-bg-tool .upload-btn:hover { background: #c9302c; }
    .remove-bg-tool .choose-file-btn { background: #D9534F; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .remove-bg-tool .choose-file-btn:hover { background: #c9302c; }
    .remove-bg-tool .preview-section { margin-top: 2em; text-align: center; display: none; }
    .remove-bg-tool .preview-section h3 { color: #4682B4; margin-bottom: 1em; }
    .remove-bg-tool .uploaded-preview { max-width: 100%; max-height: 300px; border-radius: 0.5em; margin: 1em 0; border: 2px solid #EAE3D5; }
    .remove-bg-tool .controls-section { display: none; margin: 2em 0; background: #FDFBF5; border-radius: 0.7em; padding: 1.2em; border: 1px solid #FFEAA7; }
    .remove-bg-tool .controls-section h3 { color: #4682B4; margin-bottom: 1em; font-weight: 600; }
    .remove-bg-tool .form-group { margin: 1.2em 0; }
    .remove-bg-tool .process-btn { background: #228B22; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; width: 100%; font-size: 1.1em; }
    .remove-bg-tool .process-btn:hover { background: #1e7e1e; }
    .remove-bg-tool .clear-btn { background: #6c757d; color: #fff; border: none; border-radius: 0.5em; padding: 0.8em 1.5em; font-weight: 600; cursor: pointer; transition: all 0.2s; margin-left: 1em; }
    .remove-bg-tool .clear-btn:hover { background: #5a6268; }
    .remove-bg-tool .output-preview { background: #FDFBF5; border-radius: 0.7em; padding: 1.2em; text-align: center; margin: 2em 0; border: 1px solid #FFEAA7; display: none; }
    .remove-bg-tool .output-preview h3 { color: #4682B4; margin-bottom: 1em; font-weight: 600; }
    .remove-bg-tool .preview-image { max-width: 100%; max-height: 300px; border-radius: 0.5em; margin: 1em 0; border: 2px solid #EAE3D5; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAKklEQVQYV2N89+4dAzYwiqigoIjNBEVFReYZM2ZQZgLjKKKiooLNBKSLqQAAVaYFBmKrAigAAAAASUVORK5CYII=') repeat; }
    .remove-bg-tool .output-card { display: none; margin-top: 1.5em; }
    .remove-bg-tool .btn-download { background: #228B22; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; text-decoration: none; display: inline-block; margin-right: 1em; font-size: 1.1em; }
    .remove-bg-tool .btn-download:hover { background: #1e7e1e; color: #fff; text-decoration: none; }
    .remove-bg-tool .related-links { margin-top: 2em; font-size: 1em; }
    .remove-bg-tool .related-links a { color: #D9534F; text-decoration: underline; margin-right: 1.2em; }
    .remove-bg-tool .related-links a:hover { color: #4682B4; }
    .remove-bg-tool .recent-tools { margin: 1em 0; padding: 1.2em; background: #FDFBF5; border-radius: 0.7em; font-size: 0.95em; border: 1px solid #FFEAA7; }
    .remove-bg-tool .recent-tools strong { color: #4682B4; }
    .remove-bg-tool .recent-tools a { color: #D9534F; text-decoration: none; margin: 0 0.5em; }
    .remove-bg-tool .recent-tools a:hover { color: #4682B4; text-decoration: underline; }
    .remove-bg-tool .recent-tools-list { margin-left: 0.5em; }
    .remove-bg-tool .sr-only { position: absolute; left: -10000px; top: auto; width: 1px; height: 1px; overflow: hidden; }
    .remove-bg-tool .instructions { background: #FFF3CD; border: 1px solid #FFD700; border-radius: 0.7em; padding: 1em; margin-bottom: 1.2em; color: #B8860B; font-weight: bold; font-size: 1.1em; }
    .remove-bg-tool .tool-description h2 { color: #4682B4; margin-bottom: 1em; }
    @media (max-width: 600px) { 
      .remove-bg-tool .reduce-size-container { padding: 1em 0.2em; }
      .remove-bg-tool .recent-tools { padding: 1em; }
      .remove-bg-tool .recent-tools-list { display: flex; flex-wrap: wrap; gap: 0.5em; margin-top: 0.5em; }
    }
  </style>
</head>
<body>
<main>
  <div class="remove-bg-tool">
    <div class="reduce-size-container">
      <header>
        <h1 style="font-family: 'Caveat', cursive; font-size: 3em; color: #FF6B6B; margin-bottom: 0.5em;">Remove Image Background</h1>
        <p style="font-size:1.2em; margin-bottom:1em;">Pro-quality cutouts using open-source AI in your browser. Fast, privacy-first, and free. No API.</p>
  </header>

      <div style="margin-bottom: 1.5em;">
        <span style="color: #666;">Related:</span>
        <a href="#image-compressor" style="color: #FF6B6B; text-decoration: none; margin: 0 0.5em;">Image Compressor</a>
        <a href="#image-converter" style="color: #FF6B6B; text-decoration: none; margin: 0 0.5em;">Image Converter</a>
        <a href="#watermark-images" style="color: #FF6B6B; text-decoration: none; margin: 0 0.5em;">Watermark Images</a>
      </div>

      <div style="background:#FFF3CD; border:1px solid #FFD700; border-radius:0.7em; padding:1em; margin-bottom:1.2em; color:#B8860B; font-weight:bold; font-size:1.1em;">
        ‚ú® <b>Edge-aware high-precision segmentation.</b> All processing happens locally; your image never leaves your device.
  </div>

      <section aria-labelledby="instructions-title" style="background: #F8FBFF; border-radius: 0.7em; padding: 1.5em; margin: 2em 0; border: 1px solid #4682B4;">
        <h2 id="instructions-title" style="color:#4682B4; margin-bottom: 1em; font-size: 1.5em;">How to Use</h2>
        <ol class="step-list" style="margin-left: 1.5em; line-height: 1.6;">
          <li><strong style="color: #4682B4">Upload Your Photo:</strong>
            <ul style="margin: 0.5em 0 0.5em 1.5em; color: #666;">
              <li>Drag & drop your image into the upload area</li>
              <li>Or click "Choose File" to browse</li>
              <li>Supports JPG and PNG</li>
            </ul>
          </li>
          <li><strong style="color: #4682B4">Process:</strong>
            <ul style="margin: 0.5em 0 0.5em 1.5em; color: #666;">
              <li>Click "Remove Background"</li>
              <li>First use loads the model (can take ~20s on slow network)</li>
            </ul>
          </li>
          <li><strong style="color: #4682B4">Save:</strong>
            <ul style="margin: 0.5em 0 0.5em 1.5em; color: #666;">
              <li>Preview result</li>
              <li>Download transparent PNG</li>
            </ul>
          </li>
    </ol>
  </section>

      <section style="margin-top: 2em;">
        <h2 style="color:#FF6B6B; margin-bottom: 0.5em;">Privacy Notice</h2>
        <div style="background: #FFF3CD; border: 1px solid #FFD700; border-radius: 0.7em; padding: 1em; margin-bottom: 1.2em; color: #B8860B;">
          <strong style="font-size: 1.1em;">üîí Your files are never uploaded or stored. All processing happens in your browser.</strong>
    </div>
  </section>

      <div class="tool-interface">
        <div class="upload-area" id="upload-area" tabindex="0" aria-label="Upload photo area. Drag and drop or click to select a photo." 
             ondragover="handleDragOver(event)" 
             ondragleave="handleDragLeave(event)" 
             ondrop="handleDrop(event)">
          <div class="upload-icon" aria-hidden="true">üñºÔ∏è</div>
          <h3>Drag & Drop your photo here</h3>
          <p>or click to browse files</p>
          <input type="file" id="file-input" class="file-input" accept="image/jpeg,image/png,image/webp">
          <button class="upload-btn" id="choose-file-btn" onclick="document.getElementById('file-input').click()">Choose File</button>
          <div id="upload-progress-bar" style="display:none; width:100%; background:#F0F8FF; border-radius:0.5em; margin-top:1.2em; height:1.5em; overflow:hidden; border:1px solid #B0C4DE; position:relative;">
            <div id="upload-progress-fill" style="height:100%; width:0; background:linear-gradient(90deg,#D9534F,#F0AD4E,#5BC0DE,#5CB85C,#A569BD); transition:width 0.2s;"></div>
            <span id="upload-progress-text" style="position:absolute; left:50%; top:0; transform:translateX(-50%); color:#333; font-weight:600; line-height:1.5em; font-size:1em;">Uploading: 0%</span>
          </div>
          <div id="error-message" style="display:none; color: #dc3545; margin-top: 1em; padding: 0.5em; background: #f8d7da; border-radius: 0.5em; border: 1px solid #f5c6cb;"></div>
        </div>
      </div>

      <div class="image-description" id="image-description" style="display: none; background: #E8F5E8; border: 2px solid #5CB85C; border-radius: 0.7em; padding: 1.2em; margin: 1.5em 0; text-align: center;">
        <div style="font-size: 1.5em; color: #228B22; margin-bottom: 0.5em;">üì∏</div>
        <div style="font-size: 1.1em; color: #228B22; font-weight: 600; margin-bottom: 0.5em;">Image Uploaded Successfully!</div>
        <div style="color: #666; font-size: 0.95em;" id="image-info">Ready to remove background</div>
  </div>

      <div class="preview-section" id="preview-section">
        <h3>Uploaded Image <button class="clear-btn" id="clear-btn">Clear</button></h3>
        <img id="preview-image" class="uploaded-preview">
  </div>

      <div class="controls-section" id="controls-section">
        <h3>Background Removal</h3>
        <div class="form-group">
          <button class="process-btn" id="process-btn">Remove Background</button>
        </div>
        <div id="processing" style="display:none; margin-top: 0.8em; background:#FFF3CD; border:1px solid #FFD700; border-radius:0.7em; padding:0.8em; color:#B8860B; font-weight:600; text-align:center;">
          <span id="processingText">Loading AI model...</span>
        </div>
      </div>

      <div class="output-preview" id="output-preview">
        <h3>Result Preview</h3>
        <img id="result-image" class="preview-image" />
        
        <div class="output-card" id="output-card">
          <a href="#" class="btn-download" id="download-link" download="image-no-background.png">Download PNG</a>
          <button class="clear-btn" id="download-clear-btn">Start Over</button>
        </div>
      </div>

      <div class="feature-list" style="background: #F8F9FA; border-radius: 0.7em; padding: 1.2em; margin: 1.5em 0;">
        <h2 style="color: #4682B4; margin-bottom: 1em;">Key Features</h2>
        <ul>
          <li>On-device AI background removal</li>
          <li>Transparent PNG output</li>
          <li>High-quality results</li>
          <li>Privacy-first - no uploads stored</li>
          <li>Works on all devices</li>
          <li>No registration required</li>
        </ul>
      </div>
      <nav class="recent-tools" aria-label="Recently used tools" style="background: #F8F9FA; border-radius: 0.7em; padding: 1.2em; margin: 1.5em 0;">
        <strong>Recent Tools:</strong>
        <div class="recent-tools-list" style="display: inline-block;">
          <a href="/client/tools/image/black-white-image.html">Black & White Image</a>
          <a href="/client/tools/image/image-color-picker.html">Color Picker</a>
          <a href="/client/tools/image/grayscale-image.html">Grayscale</a>
          <span class="separator" style="margin: 0 0.5em; color: #999;">‚Ä¢</span>
          <a href="#" id="clear-recent" style="color: #D9534F; font-size: 0.9em;">Clear History</a>
        </div>
      </nav>
    </div>
  </div>
</main>

<script>
(function() {
  const sources = [
    'https://cdn.jsdelivr.net/npm/rembg-js@2.1.0/dist/bundle.min.js',
    'https://cdn.jsdelivr.net/npm/rembg-js/dist/bundle.min.js',
    'https://unpkg.com/rembg-js@2.1.0/dist/bundle.min.js',
    'https://unpkg.com/rembg-js/dist/bundle.min.js'
  ];
  function loadSequential(index) {
    if (index >= sources.length) { console.warn('All rembg-js sources failed to load.'); return; }
    const s = document.createElement('script');
    s.src = sources[index];
    s.async = true;
    s.crossOrigin = 'anonymous';
    s.onload = function() { console.log('‚úÖ rembg-js loaded from', sources[index]); };
    s.onerror = function() { console.warn('Failed to load', sources[index]); setTimeout(function(){ loadSequential(index + 1); }, 100); };
    document.head.appendChild(s);
  }
  loadSequential(0);
})();
</script>
<script>
(function() {
  'use strict';

  let uploadedImage = null;
  let isInitialized = false;
  let isProcessing = false;
  let processedBlob = null;

  // Handle drag and drop events
  window.handleDragOver = function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!isProcessing) {
      document.getElementById('upload-area').style.backgroundColor = '#F0F8FF';
      document.getElementById('upload-area').style.borderColor = '#4682B4';
    }
  };

  window.handleDragLeave = function(e) {
    e.preventDefault();
    e.stopPropagation();
    document.getElementById('upload-area').style.backgroundColor = '#FDFBF5';
    document.getElementById('upload-area').style.borderColor = '#D9534F';
  };

  window.handleDrop = function(e) {
    e.preventDefault();
    e.stopPropagation();
    document.getElementById('upload-area').style.backgroundColor = '#FDFBF5';
    document.getElementById('upload-area').style.borderColor = '#D9534F';
    
    if (!isProcessing && e.dataTransfer.files.length > 0) {
      handleFile(e.dataTransfer.files[0]);
    }
  };

  window.initializeRemoveImageBackgroundTool = function() {
    if (isInitialized) { console.log('‚úÖ Remove Background Tool initialized successfully'); return; }
    console.log('üßº Initializing Remove Background Tool...');
    reset();
    init();

    // Add file input change handler
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
      fileInput.addEventListener('change', function(e) {
        if (e.target.files.length > 0) {
          handleFile(e.target.files[0]);
        }
      });
    }
  };

  function reset() {
    const elements = {
      uploadArea: document.getElementById('upload-area'),
      previewSection: document.getElementById('preview-section'),
      controlsSection: document.getElementById('controls-section'),
      outputPreview: document.getElementById('output-preview'),
      imageDescription: document.getElementById('image-description'),
      fileInput: document.getElementById('file-input'),
      resultImage: document.getElementById('result-image'),
      processing: document.getElementById('processing'),
      processingText: document.getElementById('processingText'),
      downloadLink: document.getElementById('download-link')
    };

    if (elements.uploadArea) elements.uploadArea.style.display = 'block';
    if (elements.previewSection) elements.previewSection.style.display = 'none';
    if (elements.controlsSection) elements.controlsSection.style.display = 'none';
    if (elements.outputPreview) elements.outputPreview.style.display = 'none';
    if (elements.imageDescription) elements.imageDescription.style.display = 'none';
    if (elements.processing) elements.processing.style.display = 'none';
    if (elements.fileInput) elements.fileInput.value = '';
    if (elements.resultImage) elements.resultImage.src = '';
    if (elements.downloadLink) elements.downloadLink.href = '#';
    processedBlob = null;
  }

  function init() {
    if (isInitialized) return;

    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const chooseFileBtn = document.getElementById('choose-file-btn');

    if (!uploadArea || !fileInput || !chooseFileBtn) {
      setTimeout(init, 100);
      return;
    }

    [uploadArea, fileInput, chooseFileBtn].forEach(el => {
      if (el && el.parentNode) {
        const newEl = el.cloneNode(true);
        el.parentNode.replaceChild(newEl, el);
      }
    });

    const newUploadArea = document.getElementById('upload-area');
    const newFileInput = document.getElementById('file-input');
    const newChooseFileBtn = document.getElementById('choose-file-btn');

    if (newChooseFileBtn) {
      newChooseFileBtn.onclick = function(e) {
        e.preventDefault();
        if (!isProcessing) newFileInput.click();
      };
    }

    if (newUploadArea) {
      newUploadArea.onclick = function(e) {
        if (e.target !== newChooseFileBtn && !isProcessing) newFileInput.click();
      };
    }

    if (newFileInput) {
      newFileInput.onchange = function(e) {
        if (e.target.files.length > 0) {
          const file = e.target.files[0];
          startUploadProgress(file);
          e.target.value = '';
        }
      };
    }

    if (newUploadArea) {
      newUploadArea.ondragover = function(e) {
        e.preventDefault();
        if (!isProcessing) {
          newUploadArea.style.backgroundColor = '#F0F8FF';
          newUploadArea.style.borderColor = '#4682B4';
        }
      };
      newUploadArea.ondragleave = function() {
        newUploadArea.style.backgroundColor = '#FDFBF5';
        newUploadArea.style.borderColor = '#D9534F';
      };
      newUploadArea.ondrop = function(e) {
        e.preventDefault();
        newUploadArea.style.backgroundColor = '#FDFBF5';
        newUploadArea.style.borderColor = '#D9534F';
        if (!isProcessing && e.dataTransfer.files.length > 0) {
          startUploadProgress(e.dataTransfer.files[0]);
        }
      };
    }

    const processBtn = document.getElementById('process-btn');
    if (processBtn) processBtn.onclick = processImage;

    ['clear-btn', 'download-clear-btn'].forEach(id => {
      const btn = document.getElementById(id);
      if (btn) btn.onclick = reset;
    });

    const downloadLink = document.getElementById('download-link');
    if (downloadLink) {
      downloadLink.onclick = function(e) {
        if (!processedBlob) {
          e.preventDefault();
          alert('Please process an image first');
        }
      };
    }

    isInitialized = true;
    console.log('‚úÖ Remove Background Tool initialized successfully');
  }

  function startUploadProgress(file) {
    if (isProcessing) return;
    const uploadProgressBar = document.getElementById('upload-progress-bar');
    const uploadProgressFill = document.getElementById('upload-progress-fill');
    const uploadProgressText = document.getElementById('upload-progress-text');

    const previewSection = document.getElementById('preview-section');
    const controlsSection = document.getElementById('controls-section');
    const outputPreview = document.getElementById('output-preview');
    if (previewSection) previewSection.style.display = 'none';
    if (controlsSection) controlsSection.style.display = 'none';
    if (outputPreview) outputPreview.style.display = 'none';

    if (!uploadProgressBar || !uploadProgressFill || !uploadProgressText) {
      handleFile(file);
      return;
    }

    uploadProgressBar.style.display = 'block';
    uploadProgressFill.style.width = '0%';
    uploadProgressText.textContent = 'Uploading: 0%';

    let percent = 0;
    const duration = 800 + Math.random() * 400;
    const start = Date.now();
    function animate() {
      percent = Math.min(100, Math.round(((Date.now() - start) / duration) * 100));
      uploadProgressFill.style.width = percent + '%';
      uploadProgressText.textContent = 'Uploading: ' + percent + '%';
      if (percent < 100) {
        requestAnimationFrame(animate);
      } else {
        setTimeout(() => {
          uploadProgressBar.style.display = 'none';
          handleFile(file);
        }, 200);
      }
    }
    animate();
  }

  function showError(message) {
    const errorDiv = document.getElementById('error-message');
    if (errorDiv) {
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, 5000);
    }
  }

  function handleFile(file) {
    const errorDiv = document.getElementById('error-message');
    if (errorDiv) errorDiv.style.display = 'none';
    
    if (isProcessing) {
      showError('‚ùå Please wait for the current process to complete');
      return;
    }
    isProcessing = true;

    // Validate file is provided
    if (!file) {
      showError('‚ùå No file was selected');
      isProcessing = false;
      return;
    }

    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (!allowedTypes.includes(file.type.toLowerCase())) {
      showError('‚ùå Only JPEG, PNG, and WebP images are supported');
      isProcessing = false;
      return;
    }

    // Validate file size
    const maxSize = 15 * 1024 * 1024; // 15 MB
    if (file.size > maxSize) {
      const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
      showError(`‚ùå File size (${sizeMB} MB) exceeds the 15 MB limit. Try compressing the image first`);
      isProcessing = false;
      return;
    }

    // Validate file is not empty
    if (file.size === 0) {
      showError('‚ùå The selected file appears to be empty');
      isProcessing = false;
      return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
      uploadedImage = new Image();
      uploadedImage.onload = function() {
        const previewImage = document.getElementById('preview-image');
        const imageInfo = document.getElementById('image-info');
        const imageDescription = document.getElementById('image-description');

        previewImage.src = e.target.result;
        if (imageInfo) {
          const fileSize = (file.size / 1024).toFixed(1);
          imageInfo.textContent = `${file.name} (${fileSize} KB) - Ready to remove background`;
        }

        document.getElementById('preview-section').style.display = 'block';
        document.getElementById('controls-section').style.display = 'block';
        document.getElementById('upload-area').style.display = 'none';
        if (imageDescription) imageDescription.style.display = 'block';

        isProcessing = false;
      };
      uploadedImage.onerror = function() {
        alert('Error loading image. Please try a different file.');
        isProcessing = false;
      };
      uploadedImage.src = e.target.result;
    };
    reader.onerror = function() {
      alert('Error reading file. Please try again.');
      isProcessing = false;
    };
    reader.readAsDataURL(file);
  }

  async function processImage() {
    if (!uploadedImage) {
      alert('‚ùå Please upload an image first');
      return;
    }
    if (isProcessing) return;
    isProcessing = true;

    // Handle extremely large images by resizing first
    const maxDimension = 2048; // Max dimension for processing
    let imageToProcess = uploadedImage;
    if (uploadedImage.naturalWidth > maxDimension || uploadedImage.naturalHeight > maxDimension) {
      const canvas = document.createElement('canvas');
      const scale = maxDimension / Math.max(uploadedImage.naturalWidth, uploadedImage.naturalHeight);
      canvas.width = uploadedImage.naturalWidth * scale;
      canvas.height = uploadedImage.naturalHeight * scale;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height);
      const resizedImage = new Image();
      await new Promise(resolve => {
        resizedImage.onload = resolve;
        resizedImage.src = canvas.toDataURL();
      });
      imageToProcess = resizedImage;
    }

    const processing = document.getElementById('processing');
    const processingText = document.getElementById('processingText');
    processing.style.display = 'block';
    processingText.textContent = 'Loading AI model (first use may take 20-30s)...';

    try {
      // Prefer rembg if available
      if (typeof window.Rembg !== 'undefined') {
        processingText.textContent = 'Processing with high-precision model...';
        const dataUrl = document.getElementById('preview-image').src;
        const resultUrl = await window.Rembg.remove(dataUrl, {
          progress: p => { processingText.textContent = 'AI precision cutout: ' + Math.round(p * 100) + '%'; }
        });

        const resp = await fetch(resultUrl);
        let blob = await resp.blob();
        // Try local edge refinement (U2Netp via ONNX Runtime Web)
        blob = await tryRefineEdges(blob).catch(()=>blob) || blob;
        await showBlobResult(blob);
      } else if (await ensureSelfieSegLoaded()) {
        // High-quality Google Selfie Segmentation fallback (fast, lightweight)
        processingText.textContent = 'Processing with Google Selfie Segmentation...';
        let blob = await removeBgWithSelfieSeg();
        blob = await tryRefineEdges(blob).catch(()=>blob) || blob;
        await showBlobResult(blob);
      } else {
        // Last resort: BodyPix
        processingText.textContent = 'Loading fallback model (BodyPix)...';
        await ensureBodyPixLoaded();
        processingText.textContent = 'Segmenting person...';
        let blob = await removeBgWithBodyPix();
        blob = await tryRefineEdges(blob).catch(()=>blob) || blob;
        await showBlobResult(blob);
      }
    } catch (e) {
      console.error(e);
      processingText.textContent = 'Error: ' + (e && e.message ? e.message : e);
    } finally {
      isProcessing = false;
    }
  }

  async function showBlobResult(blob) {
    const processing = document.getElementById('processing');
    const resultImage = document.getElementById('result-image');
    const outputPreview = document.getElementById('output-preview');
    const outputCard = document.getElementById('output-card');
    const downloadLink = document.getElementById('download-link');

    // Verify blob integrity
    if (!blob || blob.size === 0) {
      alert('‚ùå Processing failed: Invalid result. Please try again.');
      processing.style.display = 'none';
      isProcessing = false;
      return;
    }

    try {
      // Verify the processed image loads correctly
      const testLoad = new Image();
      await new Promise((resolve, reject) => {
        testLoad.onload = resolve;
        testLoad.onerror = reject;
        testLoad.src = URL.createObjectURL(blob);
      });

      processedBlob = blob;
      const objectUrl = URL.createObjectURL(blob);
      resultImage.src = objectUrl;
      downloadLink.href = objectUrl;
      
      // Add file extension based on output format
      const fileName = 'image-no-background.png';
      downloadLink.download = fileName;

      const existingSuccess = outputPreview.querySelector('[data-success]');
      if (existingSuccess) existingSuccess.remove();
      const successMsg = document.createElement('div');
      successMsg.setAttribute('data-success', '');
      successMsg.style.cssText = 'background: #E8F5E8; border: 2px solid #5CB85C; border-radius: 0.7em; padding: 1.2em; margin: 1.5em 0; text-align: center;';
      successMsg.innerHTML = '<div style="font-size: 1.5em; color: #228B22; margin-bottom: 0.5em;">‚úÖ</div><div style="font-size: 1.1em; color: #228B22; font-weight: 600; margin-bottom: 0.5em;">Success!</div><div style=\"color: #666; font-size: 0.95em;\">Background removed successfully. Click the download button below to save your image.</div>';
      outputPreview.insertBefore(successMsg, outputCard);

      outputPreview.style.display = 'block';
      outputCard.style.display = 'block';
      processing.style.display = 'none';
    } catch (error) {
      showError('‚ùå Error processing the image. Please try again.');
      console.error('Error displaying result:', error);
      processing.style.display = 'none';
    }
  }

  // --- Fallback: TensorFlow.js BodyPix ---
  async function ensureBodyPixLoaded() {
    if (window.bodyPix && window.tf) return;
    // Load tfjs core and body-pix sequentially
    await loadScriptOnce('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js');
    await loadScriptOnce('https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js');
  }

  function loadScriptOnce(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector('script[src="' + src + '"]')) return resolve();
      const s = document.createElement('script');
      s.src = src; s.async = true; s.crossOrigin = 'anonymous';
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('Failed to load ' + src));
      document.head.appendChild(s);
    });
  }

  // --- Edge Refinement: U2Netp via ONNX Runtime Web ---
  async function ensureOnnxRuntime() {
    if (window.ort) return;
    await loadScriptOnce('https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js');
  }

  async function tryRefineEdges(inputBlob) {
    try {
      await ensureOnnxRuntime();
      // Prefer local models; try MODNet then U2Net
      const localCandidates = [
        '/client/vendor/models/modnet.onnx',
        '/client/vendor/models/u2net.onnx'
      ];
      let session = null;
      for (const url of localCandidates) {
        try {
          session = await ort.InferenceSession.create(url, { executionProviders: ['wasm'] });
          console.log('‚úÖ Loaded local edge model:', url);
          break;
        } catch (e) { console.warn('Edge model not found/failed:', url); }
      }
      if (!session) throw new Error('No local edge model available');

      // Prepare input tensor: resize to 320x320, normalize to [0,1]
      const inImg = await createImageBitmap(inputBlob);
      const resized = document.createElement('canvas');
      resized.width = 320; resized.height = 320;
      const rctx = resized.getContext('2d');
      rctx.drawImage(inImg, 0, 0, 320, 320);
      const { data: rgba } = rctx.getImageData(0, 0, 320, 320);
      const chw = new Float32Array(1 * 3 * 320 * 320);
      for (let i = 0, p = 0; i < rgba.length; i += 4, p++) {
        const r = rgba[i] / 255, g = rgba[i + 1] / 255, b = rgba[i + 2] / 255;
        const x = p;
        chw[0 * 320 * 320 + x] = r;
        chw[1 * 320 * 320 + x] = g;
        chw[2 * 320 * 320 + x] = b;
      }
      const input = new ort.Tensor('float32', chw, [1, 3, 320, 320]);
      const inputName = (session.inputNames && session.inputNames[0]) || 'input' || 'x';
      const outputMap = await session.run({ [inputName]: input });
      const outName = (session.outputNames && session.outputNames[0]) || Object.keys(outputMap)[0];
      const out = outputMap[outName]; // 1x1x320x320 or similar
      const mask = out.data;

      // Upscale mask to original size and blend alpha with existing transparency
      const w = inImg.width, h = inImg.height;
      const mcan = document.createElement('canvas');
      mcan.width = 320; mcan.height = 320;
      const mctx = mcan.getContext('2d');
      const maskImg = mctx.createImageData(320, 320);
      for (let i = 0; i < 320 * 320; i++) {
        const v = Math.max(0, Math.min(255, Math.round(mask[i] * 255)));
        maskImg.data[i * 4 + 0] = v;
        maskImg.data[i * 4 + 1] = v;
        maskImg.data[i * 4 + 2] = v;
        maskImg.data[i * 4 + 3] = 255;
      }
      mctx.putImageData(maskImg, 0, 0);

      const up = document.createElement('canvas');
      up.width = w; up.height = h;
      const upctx = up.getContext('2d');
      upctx.drawImage(mcan, 0, 0, w, h);
      const upData = upctx.getImageData(0, 0, w, h).data;

      const base = document.createElement('canvas');
      base.width = w; base.height = h;
      const bctx = base.getContext('2d');
      bctx.drawImage(inImg, 0, 0);
      const baseData = bctx.getImageData(0, 0, w, h);
      const bd = baseData.data;

      // Build grayscale alpha from upscaled matte
      const alpha = new Uint8ClampedArray(w * h);
      for (let i = 0; i < w * h; i++) alpha[i] = upData[i * 4];

      // Edge-aware refinement: small morphological open/close + gaussian blur
      const refined = edgeRefineAlpha(alpha, w, h);

      for (let i = 0; i < w * h; i++) {
        const aIndex = i * 4 + 3;
        // Blend current alpha with refined matte (take max to preserve FG)
        bd[aIndex] = Math.max(bd[aIndex], refined[i]);
      }
      bctx.putImageData(baseData, 0, 0);

      return await new Promise(resolve => base.toBlob(b => resolve(b), 'image/png'));
    } catch (e) {
      console.warn('Edge refinement skipped:', e);
      return inputBlob;
    }
  }

  // Lightweight edge-aware alpha refinement
  function edgeRefineAlpha(alpha, width, height) {
    // 1) Morphological open (erode then dilate) to remove halos
    const eroded = morph(alpha, width, height, 1, 'erode');
    const opened = morph(eroded, width, height, 1, 'dilate');
    // 2) Morphological close (dilate then erode) to fill small gaps
    const dil = morph(opened, width, height, 1, 'dilate');
    const closed = morph(dil, width, height, 1, 'erode');
    // 3) Gentle gaussian blur for soft edges
    const blurred = gaussianBlur(closed, width, height, 1.2);
    // 4) Contrast stretch to keep edges crisp
    for (let i = 0; i < blurred.length; i++) {
      let v = blurred[i] / 255;
      v = Math.min(1, Math.max(0, (v - 0.05) * 1.15));
      blurred[i] = Math.round(v * 255);
    }
    return blurred;
  }

  function morph(src, w, h, radius, type) {
    const dst = new Uint8ClampedArray(src.length);
    const comp = type === 'erode' ? 255 : 0;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let v = comp;
        for (let dy = -radius; dy <= radius; dy++) {
          const yy = Math.min(h - 1, Math.max(0, y + dy));
          for (let dx = -radius; dx <= radius; dx++) {
            const xx = Math.min(w - 1, Math.max(0, x + dx));
            const p = src[yy * w + xx];
            if (type === 'erode') v = Math.min(v, p); else v = Math.max(v, p);
          }
        }
        dst[y * w + x] = v;
      }
    }
    return dst;
  }

  function gaussianBlur(src, w, h, sigma) {
    const kernelSize = Math.max(3, (Math.ceil(sigma * 3) * 2 + 1));
    const kernel = new Float32Array(kernelSize);
    const half = (kernelSize - 1) / 2;
    let sum = 0;
    for (let i = 0; i < kernelSize; i++) {
      const x = i - half; const val = Math.exp(-(x * x) / (2 * sigma * sigma));
      kernel[i] = val; sum += val;
    }
    for (let i = 0; i < kernelSize; i++) kernel[i] /= sum;

    const tmp = new Float32Array(w * h);
    const out = new Uint8ClampedArray(w * h);

    // Horizontal
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let acc = 0;
        for (let k = -half; k <= half; k++) {
          const xx = Math.min(w - 1, Math.max(0, x + k));
          acc += src[y * w + xx] * kernel[k + half];
        }
        tmp[y * w + x] = acc;
      }
    }
    // Vertical
    for (let x = 0; x < w; x++) {
      for (let y = 0; y < h; y++) {
        let acc = 0;
        for (let k = -half; k <= half; k++) {
          const yy = Math.min(h - 1, Math.max(0, y + k));
          acc += tmp[yy * w + x] * kernel[k + half];
        }
        out[y * w + x] = Math.round(acc);
      }
    }
    return out;
  }

  // --- Preferred Fallback: MediaPipe Selfie Segmentation ---
  async function ensureSelfieSegLoaded() {
    if (window.SelfieSegmentation) return true;
    try {
      await loadScriptOnce('https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js');
      return !!window.SelfieSegmentation;
    } catch (e) {
      try {
        await loadScriptOnce('https://unpkg.com/@mediapipe/selfie_segmentation/selfie_segmentation.js');
        return !!window.SelfieSegmentation;
      } catch (e2) {
        return false;
      }
    }
  }

  async function removeBgWithSelfieSeg() {
    return new Promise(async (resolve, reject) => {
      try {
        const imgEl = document.getElementById('preview-image');
        const seg = new SelfieSegmentation({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}` });
        seg.setOptions({ modelSelection: 1 });
        seg.onResults(async (results) => {
          try {
            const srcW = imgEl.naturalWidth || imgEl.width;
            const srcH = imgEl.naturalHeight || imgEl.height;
            const out = document.createElement('canvas');
            out.width = srcW; out.height = srcH;
            const octx = out.getContext('2d');

            // results.segmentationMask is a canvas; use it as alpha mask
            const maskSource = results.segmentationMask; // may be Image/Canvas/Video

            // Draw original
            octx.drawImage(imgEl, 0, 0, srcW, srcH);

            // Get imageData and apply mask as alpha with feathering
            const imgData = octx.getImageData(0, 0, srcW, srcH);
            const data = imgData.data;

            // Normalize mask source to a canvas at src size
            const mcan = document.createElement('canvas');
            mcan.width = srcW; mcan.height = srcH;
            const mctx = mcan.getContext('2d');
            mctx.drawImage(maskSource, 0, 0, srcW, srcH);
            const maskPixels = mctx.getImageData(0, 0, srcW, srcH).data;

            // Apply alpha; feather edges by mapping grayscale to alpha
            for (let i = 0, p = 0; i < data.length; i += 4, p += 4) {
              const m = maskPixels[p]; // R channel
              const alpha = Math.min(255, Math.max(0, m));
              data[i + 3] = alpha; // set alpha
            }
            octx.putImageData(imgData, 0, 0);

            out.toBlob(b => b ? resolve(b) : reject(new Error('Failed to create PNG')), 'image/png');
          } catch (err) { reject(err); }
        });
        await seg.initialize();
        await seg.send({ image: imgEl });
      } catch (e) { reject(e); }
    });
  }

  async function removeBgWithBodyPix() {
    // Load model
    const net = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75, quantBytes: 2 });
    const imgEl = document.getElementById('preview-image');

    // Segment person; if no person, try generic part segmentation to still get a mask
    const segmentation = await net.segmentPerson(imgEl, {
      internalResolution: 'medium',
      segmentationThreshold: 0.7
    });

    // Build alpha mask
    const off = document.createElement('canvas');
    off.width = imgEl.naturalWidth || imgEl.width; 
    off.height = imgEl.naturalHeight || imgEl.height;
    const octx = off.getContext('2d');
    octx.drawImage(imgEl, 0, 0, off.width, off.height);
    const imgData = octx.getImageData(0, 0, off.width, off.height);
    const data = imgData.data;
    const mask = segmentation.data;
    for (let i = 0; i < mask.length; i++) {
      const aIndex = i * 4 + 3;
      data[aIndex] = mask[i] ? 255 : 0; // Keep person, remove background
    }
    octx.putImageData(imgData, 0, 0);

    return await new Promise(resolve => off.toBlob(b => resolve(b), 'image/png'));
  }

  // Recent tools
  const RECENT_TOOLS_KEY = 'recentImageTools';
  const MAX_RECENT_TOOLS = 4;
  function initRecentTools() {
    const clearRecentBtn = document.getElementById('clear-recent');
    if (clearRecentBtn) {
      clearRecentBtn.onclick = function(e) {
        e.preventDefault();
        localStorage.removeItem(RECENT_TOOLS_KEY);
        updateRecentToolsList();
      };
    }
    const currentToolData = { name: 'Remove Background', url: window.location.pathname };
    addToRecentTools(currentToolData);
    updateRecentToolsList();
  }
  function addToRecentTools(toolData) {
    let recentTools = JSON.parse(localStorage.getItem(RECENT_TOOLS_KEY) || '[]');
    recentTools = recentTools.filter(tool => tool.url !== toolData.url);
    recentTools.unshift(toolData);
    recentTools = recentTools.slice(0, MAX_RECENT_TOOLS);
    localStorage.setItem(RECENT_TOOLS_KEY, JSON.stringify(recentTools));
  }
  function updateRecentToolsList() {
    const recentToolsList = document.querySelector('.recent-tools-list');
    if (!recentToolsList) return;
    const recentTools = JSON.parse(localStorage.getItem(RECENT_TOOLS_KEY) || '[]');
    if (recentTools.length === 0) {
      recentToolsList.innerHTML = '<span style="color: #666;">No recent tools</span>';
      return;
    }
    const toolLinks = recentTools
      .filter(tool => tool.url !== window.location.pathname)
      .map(tool => `<a href="${tool.url}">${tool.name}</a>`)
      .join('<span class="separator" style="margin: 0 0.5em; color: #999;">‚Ä¢</span>');
    recentToolsList.innerHTML = toolLinks + 
      '<span class="separator" style="margin: 0 0.5em; color: #999;">‚Ä¢</span>' +
      '<a href="#" id="clear-recent" style="color: #D9534F; font-size: 0.9em;">Clear History</a>';
    const clearRecentBtn = document.getElementById('clear-recent');
    if (clearRecentBtn) {
      clearRecentBtn.onclick = function(e) {
        e.preventDefault();
        localStorage.removeItem(RECENT_TOOLS_KEY);
        updateRecentToolsList();
      };
    }
  }

  const originalInit = init;
  init = function() {
    originalInit();
    initRecentTools();
  };

  if (document.readyState !== 'loading') {
    setTimeout(init, 50);
  } else {
    document.addEventListener('DOMContentLoaded', function() { setTimeout(init, 50); });
  }
})();

// Legacy auto-boot support
if (typeof window !== 'undefined' && window.location && window.location.hash.includes('remove-image-background')) {
  setTimeout(function(){
    if (window.initializeRemoveImageBackgroundTool) {
      try { window.initializeRemoveImageBackgroundTool(); } catch(e) { console.warn(e); }
    }
  }, 200);
}
</script>
</body>
</html>
